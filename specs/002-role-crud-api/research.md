# Research: Role CRUD API

**Date**: 2026-02-05
**Feature**: 002-role-crud-api

## Summary

This feature extends the existing User CRUD API with Role resources and a many-to-many relationship. All technical decisions are pre-determined by the existing implementation and user constraints.

## Technical Decisions

### 1. JPA Many-to-Many Implementation

**Decision**: Use `@ManyToMany` with a join table managed by the owning side (User entity)

**Rationale**:
- Standard JPA approach for many-to-many relationships
- Join table auto-generated by Hibernate (no explicit entity needed)
- User owns the relationship since user-role endpoints are under `/users/{id}/roles`

**Alternatives Considered**:
- Explicit join entity: Rejected - adds unnecessary complexity for simple ID-to-ID mapping
- Role owns relationship: Rejected - endpoints are initiated from User side per spec

### 2. Role Name Uniqueness Constraint

**Decision**: Use `@Column(unique = true)` on Role.name field

**Rationale**:
- Database-level constraint ensures integrity even if application layer bypassed
- Standard JPA approach, no additional configuration needed
- Hibernate generates appropriate DDL constraint

**Alternatives Considered**:
- Application-level check only: Rejected - race conditions possible, less reliable

### 3. Delete Role Protection (409 Conflict)

**Decision**: Check if role has users assigned before deletion via repository count query

**Rationale**:
- Direct query is simplest implementation
- No need for cascade behavior or complex relationship management
- Clear error message when deletion blocked

**Alternatives Considered**:
- Cascade delete: Rejected - spec requires 409 Conflict, not automatic removal
- Trigger/constraint: Rejected - adds database-specific complexity

### 4. Duplicate Assignment Detection (409 Conflict)

**Decision**: Check existing assignments before adding via `contains()` on User's roles collection

**Rationale**:
- JPA Set semantics naturally prevent duplicates
- Checking before save provides clear error response per spec
- No additional database constraints needed

**Alternatives Considered**:
- Unique constraint on join table: Would throw exception, harder to provide clean 409 response

### 5. Controller Structure

**Decision**: Separate RoleController for `/roles` endpoints, extend UserController for `/users/{id}/roles` endpoints

**Rationale**:
- RoleController handles Role CRUD (POST/GET/PUT/DELETE on /roles)
- UserController handles user-role relationship (GET/POST/DELETE on /users/{id}/roles)
- Keeps related functionality together
- Minimizes changes to existing code

**Alternatives Considered**:
- Single mega-controller: Rejected - violates single responsibility
- UserRoleController: Rejected - unnecessary additional class for 3 endpoints

## Dependencies

No new dependencies required. Existing stack sufficient:
- Spring Boot 3.5.10
- Spring Data JPA
- PostgreSQL Driver
- Testcontainers (for tests)

## Infrastructure

No changes to Docker infrastructure required:
- Dockerfile: No changes needed
- docker-compose.yml: No changes needed
- docker-compose.test.yml: No changes needed

## Unknowns Resolved

All technical aspects are determined by:
1. Existing implementation patterns (from 001-user-crud-api)
2. User-specified constraints (Docker-only, PostgreSQL-only, Spring Boot 3.5.10)
3. Spec requirements (many-to-many, unique names, 409 on conflicts)

No NEEDS CLARIFICATION items remain.
